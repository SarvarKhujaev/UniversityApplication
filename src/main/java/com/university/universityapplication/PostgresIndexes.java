package com.university.universityapplication;

/*
Для других операций с индексом используются команды:
● ALTER INDEX143 - изменить индекс
● DROP INDEX144 - удалить индекс
● REINDEX145 - перестроить индекс заново, используется, когда было
много вставок, обновлений и удалений, и информация на страницах
индекса уже расположена не оптимальным образом, записывая
новую версию индекса без мёртвых страниц146. Не забываем
указывать CONCURRENTLY!

Плюсы индексов:
● Ускоряют выборку в операциях SELECT, UPDATE, DELETE, INSERT
● При выборке данных только индексного поля, данные из таблицы
не выбираются
● Увеличение скорости сортировки по индексному полю
● Обеспечение уникальности

Минусы индексов:
● Индексы требуют дополнительного места
● Необходимо перестраивать индексы при операциях UPDATE,
DELETE, INSERT
● При большом количестве индексов оптимизатору сложно выбрать
какой использовать

Составной индекс.
    Это когда используется два и более полей для построения индекса. Здесь
    есть своя особенность: сначала строится дерево по первому индексу, затем уже
    внутри данные отсортированы по второму и последующим индексам. Исходя из
    концепции - при поиске только по второму индексу - составной индекс
    задействован не будет.

Также индексы используются и при сортировке.
Причём и при обратной сортировке тоже!
Естественно, если будет задействовано только вложенное поле в составном индексе
или будет разнонаправленная сортировка - индекс использован не будет

Частичные индексы.
    Частичный индекс - индекс, который строится по подмножеству строк
    таблицы, определяемому условным выражением:
    CREATE INDEX name ON table_name(column) WHERE condition;

    Плюсы:
        ● позволяют избежать индексирования распространенных значений
        ● позволяют исключить из индекса значения, которые обычно не
        представляют интереса

Покрывающие индексы.
    Предназначены для включения столбцов, которые требуются в определенных часто выполняемых запросах.

    CREATE INDEX name ON table_name(column1) INCLUDE (column2);

    Создается индекс, в котором столбец column2 будет «дополнительной нагрузкой», но не войдет в поисковый ключ.
    ● Плюс: для запросов, включающих вывод column2, не нужно обращаться к основной таблице - больше скорость
    ● Минус: требуется дополнительное место, дублирование информации

Хэш-индекс (hash).
    Работает только с условием равенства (=).
    В условиях IS NULL и IS NOT NULL так же не используется.
    Создаём корзины, куда складываем значения по хэшу поля,
    соответственно, всегда знаем, в какой корзине находятся строки. При
    совпадении хэша у разных строк идём по пути полного перебора строк в корзине.
    Сложность алгоритма при этом О(1) - поиск за константное время -
    быстрее О(log n).
*/
public final class PostgresIndexes {
    /*
    Btree (btree) - сбалансированное дерево (по умолчанию).
    Используется в 99% индексов.

    Применим для любого типа, который можно отсортировать в чётко
    определённом линейном порядке. Поддерживает:
    ● операторы сравнения >, <, =, >=, <=, BETWEEN и IN
    ● условия пустоты IS NULL и IS NOT NULL
    ● операторы поиска подстроки LIKE и ~, если искомая строка
    закреплена в начале шаблона (например str LIKE 'search%')
    ● регистронезависимые операторы поиска подстроки ILIKE и ~* (но
    только в том случае, если искомая строка начинается с символа,
    который одинаков и в верхнем, и в нижнем регистре, например,
    числа)

    Индексы Btree дополнительно принимают эти параметры:

    deduplicate_items - управляет механизмом исключения дубликатов. Это
    механизм формирования одной строки со списком идентификаторов для каждой
    группы - значения ключевых столбцов хранятся в единственном экземпляре, а
    за ними идёт отсортированный массив идентификаторов TID, указывающих на
    строки в таблице.

    Это существенно уменьшает размер хранимых индексов, в которых
    каждое значение (или каждое уникальное сочетание значений столбцов)
    появляется в среднем несколько раз. В результате может значительно
    увеличиться скорость выполнения запросов, а также могут сократиться
    издержки, связанные с регулярной очисткой индексов. Default - ON.
    Необходимо учитывать, что после выключения параметра
    deduplicate_items командой ALTER INDEX при добавлении в будущем новых
    элементов дубликаты исключаться не будут, но представление существующих
    строк не поменяется на стандартное.

    vacuum_cleanup_index_scale_factor - определяет процент от общего
        числа строк, подсчитанных при последнем сборе статистики, который может
        быть вставлен без необходимости сканирования индекса на стадии очистки при
        выполнении VACUUM.

    Индексы в B будут в любом случае сканироваться на стадии очистки
    VACUUM, когда выполняется хотя бы одно из следующих условий:
        ● статистика индексов устарела
        ● индекс содержит удалённые страницы, которые могут быть переработаны при очистке

    Статистика индекса считается устаревшей, если число недавно
    вставленных строк превышает процент vacuum_cleanup_index_scale_factor от
    общего числа строк, полученных при предыдущем сборе статистики.
    Когда vacuum_cleanup_index_scale_factor равен 0, сканирование
    индекса на этапе очистки VACUUM не пропускается никогда. Default - 0.1.
    */
    public static final String BTREE = "BTREE";

    /*
    GiST индекс (Generalized Search Tree).
    Или обобщённое поисковое дерево.
    Представляет собой базовый шаблон, на основе которого могут
    реализовываться произвольные схемы индексации, например, Btree, R-деревья
    и другие схемы индексации. Для построения индексов используют один из
    нескольких алгоритмов, наиболее подходящих под тип индексируемого поля,
    поэтому набор операторов зависит от типа поля.
    Применяется для специфических типов данных: геометрии, сетевые
    адреса, диапазоны

    Индексы GiST дополнительно принимают этот параметр:
    buffering - будет ли при построении индекса использоваться буферизация.
    Default AUTO - отключена вначале, но может затем включиться на ходу,
    как только размер индекса достигнет значения effective_cache_size.
    */
    public static final String GIST = "GIST";

    /*
    Индексы GIN принимают другие параметры:

    fastupdate - управляет механизмом быстрого обновления. Default - ON.

    gin_pending_list_limit - задаёт максимальный размер очереди записей GIN,
    которая используется, когда включён режим fastupdate.

    Если размер очереди превышает заданный предел, записи из неё массово переносятся в
    основную структуру данных индекса GIN, и очередь очищается.

    Default - 4MB

    GIN индекс (Generalized Inverted Index).
    Это обобщённый инвертированный индекс.
    Применяется к составным типам, работа с которыми осуществляется с
    помощью ключей: массивы, jsonb.GIN.
    Предназначается для случаев, когда индексируемые значения являются
    составными, а запросы ищут значения элементов в этих составных объектах.
    Самый распространённый вариант использования индексов GIN & GiST -
    полнотекстовый поиск149 по аналогии с Google/Yandex.

    Для работы с полнотекстовым поиском используются две функции150:

    ● to_tsvector - преобразует строку в вектор, содержащий корни слов,
    по которым будет в дальнейшем произведён поиск

    ● to_tsquery - преобразует запрос в вектор, содержащий корни слов,
    которые и будут найдены в массиве векторов to_tsvector

    Например, чтобы узнать, есть ли “толстая” и “кошка” в строке для поиска:
    SELECT to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat & rat');
    */
    public static final String GIN = "GIN";

    /*
    Индексы BRIN142 принимают другие параметры:
    pages_per_range - сколько блоков таблицы образуют зону блоков для
    каждой записи в индексе BRIN.
    Default - 128

    BRIN индекс (Block Range Index) - индекс зон блоков.
    Предназначается для обработки очень больших таблиц, в которых
    определённые столбцы некоторым естественным образом коррелируют с их
    физическим расположением в таблице.
    Зона блоков - группа страниц, физически расположенных в таблице рядом;
    для каждой зоны в индексе сохраняется некоторая сводная информация.
    */
    public static final String BRIN = "BRIN";

    /*
    SP-GiST индекс (Space-Partitioned GiST).
    Это GiST с разбиением пространства.
    Метод поддерживает деревья поиска с разбиением, что позволяет
    работать с различными несбалансированными структурами данных (деревья
    квадрантов, k-мерные и префиксные деревья).
    Как и GiST, SP-GiST позволяет разрабатывать дополнительные типы
    данных с соответствующими методами доступа.
    */
    public static final String SP_GIST = "SP-GiST";
}
